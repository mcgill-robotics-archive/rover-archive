if (sim_call_type==sim_childscriptcall_initialization) then 
    -- This is executed exactly once, the first time this script is executed
    BaseObj=simGetObjectAssociatedWithScript(sim_handle_self) -- this is bubbleRob's handle
    -- following is the handle of bubbleRob's associated UI (user interface):
    ctrl=simGetUIHandle("UI")
    -- Set the title of the user interface: 
    simSetUIButtonLabel(ctrl,0,simGetObjectName(BaseObj).." speed") 
    minMaxSpeedX={-0.1,0.1} -- Min and max speeds for each motor
	minMaxSpeedY={-0.1,0.1} -- Min and max speeds for each motor
	minMaxSpeedZ={-0.1,0.1} -- Min and max speeds for each motor
	minMaxSpeedA={-1,1} -- Min and max speeds for each motor
	minMaxSpeedB={-1,1} -- Min and max speeds for each motor
	minMaxSpeedG={-1,1} -- Min and max speeds for each motor

	Kp=10
	Ki=0
	Kd=0

	pointContainer=simAddDrawingObject(sim_drawing_lines, 3,0,-1,20000,{75,0,0},{0,0,0},{0,0,0},lightColor) 



    ---wrist = {{-400,-100,333},
    --{-400,-210,373}}
	Rot = {0,0,-1,0,0,1,0,0,1,0,0,0}

    maxrot = 0.5
	minrot = -0.5
	maxRotLimit = {0,0,0,0,0,0}
	minRotLimit = {0,0,0,0,0,0}
	Vj = {0.0,0.0,0.0,0.0,0.0,0.0}
	dAngle = {0,0,0,0,0,0}
	lastJ = {}
	wristPos = {}
	wristStep = 1
	lastWristPos = {}
	angletol = 0.001
	accelLimit = 2
	wristcount  = 0

	previous_error = 0
	integral = 0 



	simSetUIButtonLabel(ctrl,4,500)
	simSetUIButtonLabel(ctrl,6,500)
	simSetUIButtonLabel(ctrl,8,500)
	simSetUIButtonLabel(ctrl,10,500)
	simSetUIButtonLabel(ctrl,12,500)
	simSetUIButtonLabel(ctrl,14,500)

	j1 = simGetObjectHandle("joint1")
	j2 = simGetObjectHandle("joint2")
	j3 = simGetObjectHandle("joint3")
	j4 = simGetObjectHandle("joint4")
	j5 = simGetObjectHandle("joint5")
	j6 = simGetObjectHandle("joint6")
	wristHandle = simGetObjectHandle("operatingPoint")

	jointRanges = {{math.rad(0), math.rad(360)},
				  {math.rad(-10), math.rad(120)},
				  {math.rad(-65), math.rad(120)},
				  {math.rad(0), math.rad(360)},
				  {math.rad(70), math.rad(290)},
				  {math.rad(-180), math.rad(180)}}

	function split(str, sep)
		sep = sep or ','
		fields={}
		local matchfunc = string.gmatch(str, "([^"..sep.."]+)")
		if not matchfunc then return {str} end
		for str in matchfunc do
			table.insert(fields, str)
		end
		return fields
	end

	function deg2rad(degrees)
		local radians
		radians = degrees * (math.pi / 180)
		return radians
	end

	function transpose(matrix)

		local transposedM = {}
		transposedM = {matrix[1], matrix[5],matrix[9],matrix[4],
						matrix[2],matrix[6],matrix[10],matrix[8],
						matrix[3],matrix[7],matrix[11],matrix[12]}
		return transposedM
	end

	function addline(lastPosition, CurrPosition,DrawingHandle)

		simAddDrawingObjectItem(DrawingHandle,{lastPosition[1],lastPosition[2],lastPosition[3],
								CurrPosition[1],CurrPosition[2],CurrPosition[3]})

	end

	function armikp(wrist,rotation,jointRanges)

		a = {0,457,0,0,0,0}
		b = {76,0,0,400,0,50}
		alpha = {90,0,90,90,90,0}
		lam = {math.cos(deg2rad(alpha[1])),math.cos(deg2rad(alpha[2])),math.cos(deg2rad(alpha[3])),
			   math.cos(deg2rad(alpha[4])),math.cos(deg2rad(alpha[5])),math.cos(deg2rad(alpha[6]))}
		mu = {math.sin(deg2rad(alpha[1])),math.sin(deg2rad(alpha[2])),math.sin(deg2rad(alpha[3])),
			   math.sin(deg2rad(alpha[4])),math.sin(deg2rad(alpha[5])),math.sin(deg2rad(alpha[6]))}

		eps = 0.0000001
		root_tol = 0.01
		theta = {}
		eta = {0,0,0}
		Q3Q2Q1 = {}
		w = {}
		
		for i = 1, 6 do
			theta[i] = {}

			for j = 1, 8 do
				theta[i][j] = 0 
			end
		end

		xc = wrist[1]
		yc = wrist[2]
		zc = wrist[3]

		Q = transpose(rotation)
		e6 = simMultiplyVector(Q,{0,0,1})

		theta[1][1] = 2*math.atan((xc+math.sqrt(yc*yc+xc*xc+eps))/(-yc+eps))
		theta[1][2]=  2*math.atan((xc-math.sqrt(yc*yc+xc*xc+eps))/(-yc+eps))
		theta[1][3] = theta[1][1]
		theta[1][4] = theta[1][2]

		theta[3][1] = 2*math.atan((-2*a[2]*b[4]*mu[3]+math.sqrt(eps+4*a[2]^2*b[4]^2*mu[3]^2-
					  (a[2]^2+b[4]^2-xc^2-yc^2-(zc-b[1])^2)^2))/(a[2]^2+b[4]^2-xc^2-yc^2-(zc-b[1])^2+eps));
		theta[3][2] = theta[3][1];
		theta[3][3]= 2*math.atan((-2*a[2]*b[4]-math.sqrt(eps+4*a[2]^2*b[4]^2-
					 (a[2]^2+b[4]^2-xc^2-yc^2-(zc-b[1])^2)^2))/(a[2]^2+b[4]^2-xc^2-yc^2-(zc-b[1])^2+eps))
		theta[3][4] = theta[3][3]

		for i = 1,4 do
			A11 = a[2]+b[4]*math.sin(theta[3][i])
			A12 = b[4]*lam[2]*mu[3]*math.cos(theta[3][i])+b[4]*mu[2]*lam[3]
			delta2 = A11*A11+A12*A12

			cosroot1 = math.acos(math.max(math.min(1/delta2*(A11*(xc*math.cos(theta[1][i])+yc*math.sin(theta[1][i]))-A12*((zc-b[1])*mu[1])),1),-1))
			cosroot2 = -cosroot1+2*math.pi

			temp_root = (1/delta2*(A12*(xc*math.cos(theta[1][i])+yc*math.sin(theta[1][i]))+A11*((zc-b[1])*mu[1])))
			sinroot1 = math.asin(temp_root)
			if temp_root >=0 then
				sinroot2 = math.pi-sinroot1
				sinroot1 = math.asin(temp_root)
			else
				sinroot1 = sinroot1+2*math.pi
				sinroot2 = 3*math.pi-sinroot1
			end

			if (math.abs(cosroot1-sinroot1)< root_tol or math.abs(cosroot1-sinroot2)< root_tol) then
				theta[2][i] = cosroot1
			else 
				theta[2][i] = cosroot2
			end
		end

		for j = 1,4 do

			-- orientation

			eta[1] = (math.cos(theta[1][j])*math.cos(theta[2][j])*math.cos(theta[3][j])-math.cos(theta[1][j])*math.sin(theta[2][j])*math.sin(theta[3][j]))*e6[1]+
			 (math.sin(theta[1][j])*math.cos(theta[2][j])*math.cos(theta[3][j])-math.sin(theta[1][j])*math.sin(theta[2][j])*math.sin(theta[3][j]))*e6[2]+
			 (math.cos(theta[2][j])*math.sin(theta[3][j]) + math.sin(theta[2][j])*math.cos(theta[3][j]))*e6[3]
			 
			eta[2] = math.sin(theta[1][j])*e6[1]-math.cos(theta[1][j])*e6[2]

			eta[3] = (math.cos(theta[1][j])*math.cos(theta[2][j])*math.sin(theta[3][j])+math.cos(theta[1][j])*math.sin(theta[2][j])*math.cos(theta[3][j]))*e6[1]+
			 (math.sin(theta[1][j])*math.cos(theta[2][j])*math.sin(theta[3][j])+math.sin(theta[1][j])*math.sin(theta[2][j])*math.cos(theta[3][j]))*e6[2]+
			 (math.sin(theta[2][j])*math.sin(theta[3][j]) - math.cos(theta[2][j])*math.cos(theta[3][j]))*e6[3]
			 
			theta[4][j] = 2*math.atan((eta[1]*mu[4]+math.sqrt((eta[1]^2+eta[2]^2)*mu[4]^2-(lam[5]-eta[3]*lam[4])^2))
				 /(lam[5]-eta[3]*lam[4]-eta[2]*mu[4]))

			theta[4][j+4] = 2*math.atan((eta[1]*mu[4]-math.sqrt((eta[1]^2+eta[2]^2)*mu[4]^2-(lam[5]-eta[3]*lam[4])^2))
				 /(lam[5]-eta[3]*lam[4]-eta[2]*mu[4]))
				 
			Q3Q2Q1 = {((math.cos(theta[2][j])*math.cos(theta[3][j]) - math.sin(theta[2][j])*math.sin(theta[3][j]))*math.cos(theta[1][j])),
					((math.cos(theta[2][j])*math.cos(theta[3][j]) - math.sin(theta[2][j])*math.sin(theta[3][j]))*math.sin(theta[1][j])),
					(math.cos(theta[2][j])*math.sin(theta[3][j]) + math.sin(theta[2][j])*math.cos(theta[3][j])),
					0,
					math.sin(theta[1][j]),
					-math.cos(theta[1][j]),
					0,
					0,
					((math.cos(theta[2][j])*math.sin(theta[3][j]) + math.sin(theta[2][j])*math.cos(theta[3][j]))*math.cos(theta[1][j])),
					((math.cos(theta[2][j])*math.sin(theta[3][j]) + math.sin(theta[2][j])*math.cos(theta[3][j]))*math.sin(theta[1][j])),
					(math.sin(theta[2][j])*math.sin(theta[3][j]) - math.cos(theta[2][j])*math.cos(theta[3][j])),
					0}
					
			R = simMultiplyMatrices(Q3Q2Q1,rotation);
			
			for k = j,j+4,4 do
				
				cosroot1 = math.acos(math.max(math.min(1/-mu[5]*(-lam[4]*(mu[6]*R[2]*lam[6]*R[3])*math.sin(theta[4][k]) +
						   lam[4]*(mu[6]*R[6]+lam[6]*R[7])*math.cos(theta[4][k])+mu[4]*(mu[6]*R[9]+lam[6]*R[11])),1),-1))
				cosroot2 = -cosroot1+2*math.pi

				temp_root = 1/mu[5]*((mu[6]*R[2]+lam[6]*R[3])*math.cos(theta[4][k])+(mu[6]*R[5]+lam[6]*R[7])*math.sin(theta[4][k]))
				sinroot1 = math.asin(temp_root)
				if temp_root >=0 then
					sinroot1 = math.asin(temp_root)
					sinroot2 = math.pi-sinroot1
				else
					sinroot1 = sinroot1+2*math.pi
					sinroot2 = 3*math.pi-sinroot1
				end

				if (math.abs(cosroot1-sinroot1)< root_tol or math.abs(cosroot1-sinroot2)< root_tol) then
					theta[5][k] = cosroot1
				else 
					theta[5][k] = cosroot2
				end

				w[1] = R[1]*math.cos(theta[4][k])+R[5]*math.sin(theta[4][k])
				w[2] = -lam[4]*(R[1]*math.sin(theta[4][k])-R[5]*math.cos(theta[4][k]))+mu[4]*R[9]
				w[3] = mu[4]*(R[1]*math.sin(theta[4][k])-R[5]*math.cos(theta[4][k]))+lam[4]*R[9]
				
				cosroot1 = math.acos(math.max(math.min(w[1]*math.cos(theta[5][k])+w[2]*math.sin(theta[5][k]),1),-1))
				cosroot2 = -cosroot1+2*math.pi
				
				temp_root = -w[1]*lam[5]*math.sin(theta[5][k])+w[2]*lam[5]*math.cos(theta[5][k])+w[3]*mu[5]
					sinroot1 = math.asin(temp_root)
				if temp_root >=0 then
					sinroot2 = math.pi-sinroot1
				else
					sinroot1 = sinroot1+2*math.pi
					sinroot2 = 3*math.pi-sinroot1
				end
				
				if (math.abs(cosroot1-sinroot1)< root_tol or math.abs(cosroot1-sinroot2)< root_tol) then
					theta[6][k] = cosroot1
				else 
					theta[6][k] = cosroot2
				end
			end

		end

			for i = 1,3 do
				for j = 1,4 do
					theta[i][j+4] = theta[i][j]
				end
			end

			for i = 1,6 do
				for j = 1,8 do
					if theta[i][j]-angletol <= jointRanges[i][1] then
						theta[i][j] = theta[i][j] + 2*math.pi
					else if theta[i][j]-angletol >= jointRanges[i][2] then
						theta[i][j] = theta[i][j] - 2*math.pi
						end
					end
				end
			end	
		

		return theta

	end

	function getNewTarget(currentPosition,currentTarget,tol)

	

		local target  = {}
--print(math.abs(currentPosition[1] - currentTarget[1]))
		if (math.abs(currentPosition[1] - currentTarget[1]) <tol) and
		   (math.abs(currentPosition[2] - currentTarget[2]) <tol) and
		   (math.abs(currentPosition[3] - currentTarget[3]) <tol) and
		   (math.abs(currentPosition[4] - currentTarget[4]) <tol) and
		   (math.abs(currentPosition[5] - currentTarget[5]) <tol) and
		   (math.abs(currentPosition[6] - currentTarget[6]) <tol) 
		then
			wristStep = wristStep+1
			if wristStep > 2545 then
					simPauseSimulation()
			else	
				--if wristStep == #wrist then
					
					--Rot = {1,0,0,0,0,0,1,0,0,1,0,0}
				--end
				theta = armikp(wrist[wristStep],Rot,jointRanges)
				pSolution, numSolutions = possibleSolution(theta,jointRanges)
				target = closestSolution(pSolution,numSolutions,currentPosition)

				for i = 1,6 do
					dAngle[i] = (math.abs(target[i] - currentPosition[i]))
				end
	
				largestDA = math.max(dAngle[1],dAngle[2],dAngle[3],dAngle[4],dAngle[5],dAngle[6])
				for i = 1,6 do
				maxRotLimit[i] = dAngle[i]/(largestDA+0.001)*maxrot
				minRotLimit[i] = dAngle[i]/(largestDA+0.001)*minrot
				end		
			end
		else
			target = currentTarget
		end
		
		return target
	end

   
	
	
	function closestSolution(theta,numSolutions,currentJPos)
		distanceToTarget = {}
		for i = 1,numSolutions do 
			distanceToTarget[i] = 0
			for j = 1,6 do
				distanceToTarget[i] = distanceToTarget[i] + math.abs(theta[j][i]-currentJPos[j])
			end
		end

	  local mi = 1                        -- maximum index
      local m = distanceToTarget[mi]       -- maximum value
      for i,val in ipairs(distanceToTarget) do
        if val < m then
          mi = i
          m = val
        end
      end

	  closestSol = {theta[1][mi],theta[2][mi],theta[3][mi],theta[4][mi],theta[5][mi],theta[6][mi]}

	  return closestSol



	end

	function possibleSolution(theta,jointRanges)

		numSolutions = 0
		local validSet = false
		jAngles = {}
		for i = 1, 6 do
			jAngles[i] = {}

			for j = 1, 8 do
				jAngles[i][j] = 0 
			end
		end


		for i = 1,8 do
			validSet = false
			for k = 1,3 do
				if (theta[k][i] > jointRanges[k][2] or (theta[k][i] < jointRanges[k][1]))  then
					--print("notvalid:",jointRanges[k][1],theta[k][i],jointRanges[k][2] )
					validSet = true		
				end				
			end
			if not validSet then
				numSolutions = numSolutions+1
				for j=1,6 do
				jAngles[j][numSolutions] = theta[j][i]
				end
			end
		end
		print( numSolutions)
		return jAngles, numSolutions
	end
		
	function getLastJ()

		lastJ[1] =  simGetJointPosition(j1)
		lastJ[2] =  simGetJointPosition(j2)
		lastJ[3] =  simGetJointPosition(j3)
		lastJ[4] =  simGetJointPosition(j4)
		lastJ[5] =  simGetJointPosition(j5)
		lastJ[6] =  simGetJointPosition(j6)

		return lastJ
	end

	function lowerMagnitude(a,b)

		if a*a-b*b >=0 then
			return b
		else
			return a
		end
	end

	points = {}
	 tonum = tonum or true
		sep = sep or ','
		wrist = {}
		local file = assert(io.open("MRpoints.csv", "r"))
		for line in file:lines() do
			fields = split(line, sep)
			if tonum then -- convert numeric fields to numbers
				for i=1,#fields do
					fields[i] = tonumber(fields[i]) or fields[i]
				end
			end
			table.insert(wrist, fields)
		end
		file:close()
	print(#wrist)

newTime = simGetSimulationTime()	

	lastJ = getLastJ()
	lastWristPos = simGetObjectPosition(wristHandle, -1)
	theta = armikp(wrist[1],Rot,jointRanges)
	pSolution, numSolutions = possibleSolution(theta,jointRanges)
	angles = closestSolution(pSolution,numSolutions,lastJ)
	--print(angles[1],angles[2],angles[3],angles[4],angles[5],angles[6])
	--angles = {math.pi,math.pi/2,-.5,math.pi,math.pi,0}
	
	for i = 1,6 do

		if (math.abs(angles[i])<angletol or math.abs(angles[i]-math.pi)<angletol or
		math.abs(angles[i]-lastJ[i]) < math.abs(angles[i]-lastJ[i]-2*math.pi)) then
			angles[i] = angles[i]
		else
			angles[i] = angles[i] - 2*math.pi
		end

		dAngle[i] = (math.abs(angles[i] - lastJ[i]))
	end

	largestDA = math.max(dAngle[1],dAngle[2],dAngle[3],dAngle[4],dAngle[5],dAngle[6])
	for i = 1,6 do
		maxRotLimit[i] = dAngle[i]/(largestDA+0.001)*maxrot
		minRotLimit[i] = dAngle[i]/(largestDA+0.001)*minrot
	end

end

if (sim_call_type==sim_childscriptcall_cleanup) then 
 
end 

if (sim_call_type==sim_childscriptcall_sensing) then 

end 
 
if (sim_call_type==sim_childscriptcall_actuation) then 
	
    oldTime = newTime
	newTime = simGetSimulationTime()
	dT = newTime - oldTime

	lastJ[1] =  simGetJointPosition(j1)
	lastJ[2] =  simGetJointPosition(j2)
	lastJ[3] =  simGetJointPosition(j3)
	lastJ[4] =  simGetJointPosition(j4)
	lastJ[5] =  simGetJointPosition(j5)
	lastJ[6] =  simGetJointPosition(j6)

	angles = getNewTarget(lastJ,angles,0.025)

	for i = 1,6 do

		error = angles[i] - lastJ[i]
		integral = integral + error*dT
		derivative = (error - previous_error)/dT
		output = Kp*error + Ki*integral + Kd*derivative
		previous_error = error	
		setVel = math.max(math.min(output,maxRotLimit[i]),minRotLimit[i])
		--print(error)
		if Vj[i] - setVel > 0 then
			Vj[i] = lowerMagnitude(Vj[i] - accelLimit*dT ,setVel)
		else if Vj[i] - setVel < 0 then
			Vj[i] = lowerMagnitude(Vj[i] + accelLimit*dT ,setVel)
			end
		end	
	end

	simSetJointPosition(j1,lastJ[1] +Vj[1]*dT)
	simSetJointPosition(j2,lastJ[2] +Vj[2]*dT)
    simSetJointPosition(j3,lastJ[3] +Vj[3]*dT)
	simSetJointPosition(j4,lastJ[4] +Vj[4]*dT)
	simSetJointPosition(j5,lastJ[5] +Vj[5]*dT)
    simSetJointPosition(j6,lastJ[6] +Vj[6]*dT)

	wristPos = simGetObjectPosition(wristHandle, -1)
	if wristStep >1 and wristStep <2545 then
		addline(lastWristPos, wristPos,pointContainer)
	end

	lastWristPos = wristPos


		--lastOrientation = simGetObjectOrientation(targetHandle,-1)
        --newPosition = {lastPosition[1] + speedX*dT ,lastPosition[2]+ speedY*dT ,lastPosition[3]+ speedZ*dT }
		--newOrientation = {lastOrientation[1] + speedA*dT ,lastOrientation[2]+ speedB*dT ,lastOrientation[3]+ speedG*dT }
		--simSetObjectPosition(targetHandle,-1,newPosition)
		--simSetObjectOrientation(targetHandle,-1,newOrientation)
		--simSetJointPosition(j1,lastj1 +speedX*dT)
		--simSetJointPosition(j2,lastj2 +speedY*dT)
		--simSetJointPosition(j3,lastj3 +speedZ*dT)
		--simSetJointPosition(j4,lastj4 +speedA*dT)
		--simSetJointPosition(j5,lastj5 +speedB*dT)
		--simSetJointPosition(j6,lastj6 +speedG*dT)


end